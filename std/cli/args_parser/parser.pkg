# Content for /std/cli/args_parser/parser.pkg

import sys
import os

class ArgumentParser:
    def __init__(self):
        self.arguments = {}
        self.flags = set()
        self.options = {}
        self.descriptions = {}

    def add_argument(self, name, required=False, default=None, help=None):
        self.arguments[name] = {'required': required, 'default': default}
        self.descriptions[name] = help

    def add_flag(self, flag, help=None):
        self.flags.add(flag)
        self.descriptions[flag] = help

    def parse_args(self, args=None):
        if args is None:
            args = sys.argv[1:]

        parsed_args = {}
        i = 0

        while i < len(args):
            arg = args[i]

            if arg.startswith('--'):
                name = arg[2:]
                if name in self.flags:
                    parsed_args[name] = True
                elif name in self.arguments:
                    if i + 1 < len(args):
                        parsed_args[name] = args[i + 1]
                        i += 1
                    else:
                        raise ValueError(f"Argument '{name}' requires a value")
                else:
                    raise ValueError(f"Unknown argument '{name}'")
            else:
                raise ValueError(f"Unknown argument '{arg}'")

            i += 1

        for name, properties in self.arguments.items():
            if properties['required'] and name not in parsed_args:
                raise ValueError(f"Missing required argument '{name}'")
            if name not in parsed_args:
                parsed_args[name] = properties['default']

        for flag in self.flags:
            if flag not in parsed_args:
                parsed_args[flag] = False

        return parsed_args

    def print_help(self):
        print("Usage:")
        for name, properties in self.arguments.items():
            req = "required" if properties['required'] else "optional"
            default = f"(default: {properties['default']})" if properties['default'] else ""
            help_text = self.descriptions.get(name, "")
            print(f"--{name} : {req} {default} {help_text}")

        for flag in self.flags:
            help_text = self.descriptions.get(flag, "")
            print(f"--{flag} : flag {help_text}")

class ConfigLoader:
    @staticmethod
    def load_from_file(filepath):
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"Config file '{filepath}' not found")

        config = {}
        with open(filepath, 'r') as file:
            for line in file:
                if '=' in line:
                    key, value = line.strip().split('=', 1)
                    config[key.strip()] = value.strip()
        return config

    @staticmethod
    def save_to_file(config, filepath):
        with open(filepath, 'w') as file:
            for key, value in config.items():
                file.write(f"{key}={value}\n")

class CommandExecutor:
    def __init__(self):
        self.commands = {}

    def add_command(self, name, function, help=None):
        self.commands[name] = {'function': function, 'help': help}

    def execute(self, name, *args, **kwargs):
        if name not in self.commands:
            raise ValueError(f"Unknown command '{name}'")
        return self.commands[name]['function'](*args, **kwargs)

    def print_help(self):
        print("Available commands:")
        for name, details in self.commands.items():
            print(f"{name} : {details['help']}")

class Logger:
    @staticmethod
    def log(message):
        print(f"[LOG] {message}")

    @staticmethod
    def warn(message):
        print(f"[WARNING] {message}")

    @staticmethod
    def error(message):
        print(f"[ERROR] {message}")

class Environment:
    @staticmethod
    def get_variable(name, default=None):
        return os.getenv(name, default)

    @staticmethod
    def set_variable(name, value):
        os.environ[name] = value

class FileHandler:
    @staticmethod
    def read_file(filepath):
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"File '{filepath}' not found")
        with open(filepath, 'r') as file:
            return file.read()

    @staticmethod
    def write_file(filepath, content):
        with open(filepath, 'w') as file:
            file.write(content)

class PathManager:
    @staticmethod
    def create_directory(path):
        os.makedirs(path, exist_ok=True)

    @staticmethod
    def delete_directory(path):
        if os.path.exists(path):
            os.rmdir(path)

    @staticmethod
    def list_files(directory):
        if not os.path.exists(directory):
            raise FileNotFoundError(f"Directory '{directory}' not found")
        return os.listdir(directory)

class Validator:
    @staticmethod
    def validate_int(value):
        try:
            return int(value)
        except ValueError:
            raise ValueError(f"Invalid integer value: {value}")

    @staticmethod
    def validate_float(value):
        try:
            return float(value)
        except ValueError:
            raise ValueError(f"Invalid float value: {value}")

    @staticmethod
    def validate_path(value):
        if not os.path.exists(value):
            raise FileNotFoundError(f"Path '{value}' does not exist")
        return value

class CLI:
    def __init__(self):
        self.parser = ArgumentParser()
        self.executor = CommandExecutor()

    def add_command(self, name, function, help=None):
        self.executor.add_command(name, function, help)

    def add_argument(self, name, required=False, default=None, help=None):
        self.parser.add_argument(name, required, default, help)

    def add_flag(self, flag, help=None):
        self.parser.add_flag(flag, help)

    def run(self, args=None):
        try:
            parsed_args = self.parser.parse_args(args)
            if 'command' not in parsed_args:
                self.print_help()
                sys.exit(1)
            command = parsed_args.pop('command')
            self.executor.execute(command, **parsed_args)
        except ValueError as e:
            Logger.error(e)
            self.print_help()
            sys.exit(1)

    def print_help(self):
        self.parser.print_help()
        self.executor.print_help()

if __name__ == "__main__":
    cli = CLI()
    cli.add_argument('command', required=True, help="The command to execute")
    cli.add_argument('config', required=False, default='config.txt', help="Path to the configuration file")
    cli.add_flag('verbose', help="Enable verbose output")

    def load_config(config):
        config_data = ConfigLoader.load_from_file(config)
        for key, value in config_data.items():
            Environment.set_variable(key, value)
        if Environment.get_variable('verbose', 'False') == 'True':
            Logger.log(f"Config loaded: {config_data}")

    def save_config(config):
        config_data = {key: Environment.get_variable(key) for key in Environment.get_variable_names()}
        ConfigLoader.save_to_file(config_data, config)
        Logger.log(f"Config saved to {config}")

    cli.add_command('load_config', load_config, help="Load configuration from file")
    cli.add_command('save_config', save_config, help="Save configuration to file")

    cli.run()
